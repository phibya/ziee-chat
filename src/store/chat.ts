import { create } from 'zustand'
import { subscribeWithSelector } from 'zustand/middleware'
import { ApiClient } from '../api/client'
import { Conversation, Message, MessageBranch } from '../types/api/chat'
import { useConversationsStore } from './conversations.ts'
import { getFile } from './files.ts'

export interface ChatState {
  // Current conversation state
  currentConversation: Conversation | null
  currentMessages: Message[]
  activeBranchId: string | null

  // Loading states
  loading: boolean
  sending: boolean
  loadingBranches: boolean

  // Error state
  error: string | null

  // Stream state
  streamingMessage: string
  isStreaming: boolean
}

export const useChatStore = create<ChatState>()(
  subscribeWithSelector(
    (): ChatState => ({
      // Initial state
      currentConversation: null,
      currentMessages: [],
      activeBranchId: null,
      loading: false,
      sending: false,
      loadingBranches: false,
      error: null,
      streamingMessage: '',
      isStreaming: false,
    }),
  ),
)

// Chat actions
export const createNewConversation = async (
  assistantId: string,
  modelId: string,
  projectId?: string,
): Promise<string> => {
  try {
    useChatStore.setState({ loading: true, error: null })

    const response = await ApiClient.Chat.createConversation({
      title: 'New Conversation', // This will be auto-generated by the backend
      assistant_id: assistantId,
      model_id: modelId,
      project_id: projectId,
    })

    useChatStore.setState({
      currentConversation: response,
      currentMessages: [],
      activeBranchId: response.active_branch_id,
      loading: false,
    })

    return response.id
  } catch (error) {
    useChatStore.setState({
      error:
        error instanceof Error
          ? error.message
          : 'Failed to create conversation',
      loading: false,
    })
    throw error
  }
}

export const loadConversationById = async (
  conversationId: string,
  loadMessages: boolean = true,
): Promise<void> => {
  try {
    useChatStore.setState({ loading: true, error: null })

    // Get conversation info
    const conversation = await ApiClient.Chat.getConversation({
      conversation_id: conversationId,
    })

    useConversationsStore.setState(state => ({
      conversations: state.conversations.map(conv => {
        if (conv.id === conversationId) {
          return {
            ...conv,
            title: conversation.title || conv.title,
          }
        }
        return conv
      }),
    }))

    if (loadMessages) {
      // Load messages only if requested
      const messages = await ApiClient.Chat.getConversationMessages({
        conversation_id: conversationId,
        branch_id: conversation.active_branch_id,
      })

      useChatStore.setState({
        currentConversation: conversation,
        currentMessages: messages,
        activeBranchId: conversation.active_branch_id,
        loading: false,
      })
    } else {
      useChatStore.setState({
        currentConversation: conversation,
        activeBranchId: conversation.active_branch_id,
        loading: false,
      })
    }
  } catch (error) {
    useChatStore.setState({
      error:
        error instanceof Error ? error.message : 'Failed to load conversation',
      loading: false,
    })
    throw error
  }
}

export interface SendChatMessageParams {
  conversationId: string
  content: string
  assistantId: string
  modelId: string
  fileIds?: string[]
}

export const sendChatMessage = async (
  params: SendChatMessageParams,
): Promise<void> => {
  const { conversationId, content, assistantId, modelId, fileIds } = params
  const { activeBranchId } = useChatStore.getState()
  if (!conversationId || !activeBranchId) return

  try {
    useChatStore.setState({
      sending: true,
      error: null,
      isStreaming: true,
      streamingMessage: '',
    })

    const files = await Promise.all((fileIds || []).map(getFile))

    // Add user message immediately
    const userMessage: Message = {
      id: crypto.randomUUID(),
      conversation_id: conversationId,
      content,
      role: 'user',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      edit_count: 0,
      originated_from_id: crypto.randomUUID(),
      files: files,
    }

    useChatStore.setState(state => ({
      currentMessages: [...state.currentMessages, userMessage],
    }))

    // Create assistant message placeholder
    const assistantMessage: Message = {
      id: crypto.randomUUID(),
      conversation_id: conversationId,
      content: '',
      role: 'assistant',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      edit_count: 0,
      originated_from_id: crypto.randomUUID(),
      files: [],
    }

    useChatStore.setState(state => ({
      currentMessages: [...state.currentMessages, assistantMessage],
    }))

    // Send message with streaming
    await ApiClient.Chat.sendMessageStream(
      {
        conversation_id: conversationId,
        content,
        model_id: modelId,
        assistant_id: assistantId,
        file_ids: fileIds,
      },
      {
        SSE: (event: string, data: any) => {
          if (event === 'message' || event === 'data' || event === 'chunk') {
            // Handle streaming data events
            if (data.delta) {
              useChatStore.setState(state => ({
                streamingMessage: state.streamingMessage + data.delta,
              }))
            }
          } else if (event === 'complete') {
            // Handle completion events
            useChatStore.setState(state => ({
              isStreaming: false,
              sending: false,
              streamingMessage: '',
              currentMessages: [
                ...state.currentMessages,
                {
                  ...assistantMessage,
                  content: state.streamingMessage,
                  updated_at: new Date().toISOString(),
                  id: data.message_id,
                },
              ],
            }))
          } else if (event === 'error') {
            useChatStore.setState({
              error: 'Streaming failed',
              sending: false,
              isStreaming: false,
              streamingMessage: '',
            })
          } else {
            // Log unknown event types for debugging
            console.log('Unknown SSE event type in chat:', event, data)
          }
        },
      },
    )
  } catch (error) {
    useChatStore.setState({
      error: error instanceof Error ? error.message : 'Failed to send message',
      sending: false,
      isStreaming: false,
      streamingMessage: '',
    })
    throw error
  }
}

export const editChatMessage = async (
  messageId: string,
  params: Omit<SendChatMessageParams, 'conversationId'>,
): Promise<void> => {
  const { currentConversation } = useChatStore.getState()
  if (!currentConversation) return

  try {
    useChatStore.setState({
      sending: true,
      error: null,
      isStreaming: true,
      streamingMessage: '',
    })

    const currentMessage = useChatStore
      .getState()
      .currentMessages.find(msg => msg.id === messageId)

    if (!currentMessage) {
      throw new Error('Message not found')
    }

    const files = await Promise.all((params.fileIds || []).map(getFile))

    // Update the user message immediately with the new content
    useChatStore.setState(state => {
      let currentMessages = state.currentMessages.filter(
        m => new Date(m.created_at) <= new Date(currentMessage.created_at),
      )

      return {
        currentMessages: currentMessages.map(msg =>
          msg.id === messageId
            ? { ...msg, content: params.content, files }
            : msg,
        ),
      }
    })

    // Create assistant message placeholder for streaming
    const assistantMessage: Message = {
      id: 'streaming-temp',
      conversation_id: currentConversation.id,
      content: '',
      role: 'assistant',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      edit_count: 0,
      originated_from_id: messageId,
      files: [],
    }

    useChatStore.setState(state => ({
      currentMessages: [...state.currentMessages, assistantMessage],
    }))

    // Use streaming edit endpoint
    await ApiClient.Chat.editMessageStream(
      {
        message_id: messageId,
        conversation_id: currentConversation.id,
        model_id: params.modelId,
        assistant_id: params.assistantId,
        content: params.content,
        file_ids: params.fileIds,
      },
      {
        SSE: (event: string, data: any) => {
          if (event === 'chunk') {
            // Handle streaming data events
            if (data.delta) {
              useChatStore.setState(state => ({
                streamingMessage: state.streamingMessage + data.delta,
              }))
            }
          } else if (event === 'complete') {
            // Handle completion events
            useChatStore.setState(state => ({
              isStreaming: false,
              sending: false,
              streamingMessage: '',
              currentMessages: [
                ...state.currentMessages.filter(
                  msg => msg.id !== 'streaming-temp',
                ),
                {
                  ...assistantMessage,
                  content: state.streamingMessage,
                  updated_at: new Date().toISOString(),
                  id: data.message_id,
                },
              ],
            }))
          } else if (event === 'error') {
            useChatStore.setState({
              error: 'Edit streaming failed',
              sending: false,
              isStreaming: false,
              streamingMessage: '',
              // Remove the streaming placeholder
              currentMessages: useChatStore
                .getState()
                .currentMessages.filter(msg => msg.id !== 'streaming-temp'),
            })
          } else {
            // Log unknown event types for debugging
            console.log('Unknown SSE event type in edit chat:', event, data)
          }
        },
      },
    )
  } catch (error) {
    useChatStore.setState({
      error: error instanceof Error ? error.message : 'Failed to edit message',
      sending: false,
      isStreaming: false,
      streamingMessage: '',
      // Remove the streaming placeholder on error
      currentMessages: useChatStore
        .getState()
        .currentMessages.filter(msg => msg.id !== 'streaming-temp'),
    })
    throw error
  }
}

export const loadConversationMessageBranches = async (
  messageId: string,
): Promise<MessageBranch[]> => {
  return await ApiClient.Chat.getMessageBranches({
    message_id: messageId,
  })
}

export const switchMessageBranch = async (
  conversationId: string,
  branchId: string,
): Promise<void> => {
  try {
    useChatStore.setState({ error: null })

    await ApiClient.Chat.switchConversationBranch({
      conversation_id: conversationId,
      branch_id: branchId,
    })

    // After switching, reload the conversation and get messages for the new branch
    const conversation = await ApiClient.Chat.getConversation({
      conversation_id: conversationId,
    })

    const messages = await ApiClient.Chat.getConversationMessages({
      conversation_id: conversationId,
      branch_id: branchId,
    })

    useChatStore.setState({
      currentConversation: conversation,
      currentMessages: messages,
      activeBranchId: branchId,
    })
  } catch (error) {
    useChatStore.setState({
      error: error instanceof Error ? error.message : 'Failed to switch branch',
      loading: false,
    })
    throw error
  }
}

export const stopMessageStreaming = (): void => {
  useChatStore.setState({ isStreaming: false, sending: false })
}

export const clearChatError = (): void => {
  useChatStore.setState({ error: null })
}

export const resetChatState = (): void => {
  useChatStore.setState({
    currentConversation: null,
    currentMessages: [],
    activeBranchId: null,
    loading: false,
    sending: false,
    loadingBranches: false,
    error: null,
    streamingMessage: '',
    isStreaming: false,
  })
}
